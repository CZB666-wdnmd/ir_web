#!/usr/bin/env python3
"""
ir_key_recorder.py

记录 ir-keytable 的输出，生成简单的 keymap 文件供 ir-ctl/手工使用。

交互流程（符合你的要求）：
- 程序启动后，提示：输入按键名，回车开始录制；再按回车结束本次录制。
- 重复以上步骤；如果在 "输入按键名" 阶段直接回车（空名），则保存并退出。

默认命令（程序内部会尝试）：
  stdbuf -oL ir-keytable -p <protocol> -t -s <device>
如果系统没有 stdbuf，会回退到直接运行 ir-keytable（但那可能导致行缓冲问题）。

输出文件格式（纯文本，便于手工检查/编辑）：
# keymap file generated by ir_key_recorder.py
# format: <name> <protocol> <comma-separated scancodes>
例如：POWER nec 0xa59b,0xa5dd

依赖：
- Linux 下可用 ir-keytable（来自 rc-tools / v4l-utils 等）
- 推荐在有权限的 shell 下运行（有时需要 root）

"""

import argparse
import subprocess
import threading
import re
import sys
import signal
from collections import OrderedDict

SCANCODE_RE = re.compile(r"scancode\s*=\s*(0x[0-9A-Fa-f]+)")
PROTOCOL_RE = re.compile(r"protocol\(([^)]+)\)")


def start_ir_keytable(protocol, device, use_stdbuf=True):
    """启动 ir-keytable 子进程，返回 Popen 对象和实际使用的命令列表。"""
    base_cmd = ['ir-keytable', '-p', protocol, '-t', '-s', device]
    if use_stdbuf:
        cmd = ['stdbuf', '-oL'] + base_cmd
    else:
        cmd = base_cmd
    try:
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
        return proc, cmd
    except FileNotFoundError as e:
        if use_stdbuf:
            # 可能系统没有 stdbuf，回退到不带 stdbuf 的命令
            return start_ir_keytable(protocol, device, use_stdbuf=False)
        raise


class LineReader(threading.Thread):
    """从 subprocess.stdout 读取行（阻塞），解析 scancode 并按出现顺序去重保存。
    读取会持续到 stop_event 被 set 或者子进程结束。
    """

    def __init__(self, proc, stop_event):
        super().__init__(daemon=True)
        self.proc = proc
        self.stop_event = stop_event
        self.found = []  # ordered unique scancodes seen (0x... strings)
        self.last_added = None
        self.protocol = None

    def run(self):
        try:
            # 有时候 proc.stdout 可能为 None（如果启动失败），保护性判断
            if not self.proc or not self.proc.stdout:
                return
            for raw in self.proc.stdout:
                if self.stop_event.is_set():
                    break
                line = raw.strip()
                if not line:
                    continue
                # 尝试解析 protocol
                m_proto = PROTOCOL_RE.search(line)
                if m_proto:
                    self.protocol = m_proto.group(1)
                # 解析 scancode
                m = SCANCODE_RE.search(line)
                if not m:
                    continue
                code = m.group(1).lower()
                # 全局去重但保持第一次出现的顺序
                if code not in self.found:
                    self.found.append(code)
                    print(f"  detected: {code}")
        except Exception as e:
            # 不要让线程因为解析错误崩溃
            print(f"[reader] error: {e}", file=sys.stderr)


def record_one_key(protocol, device):
    """启动 ir-keytable 并记录直到用户按回车停止。返回 (protocol_used, [codes...])
    """
    try:
        proc, cmd = start_ir_keytable(protocol, device, use_stdbuf=True)
    except Exception as e:
        print(f"无法启动 ir-keytable: {e}")
        return None, []

    print(f"Started: {' '.join(cmd)} (pid={proc.pid})")
    stop_event = threading.Event()
    reader = LineReader(proc, stop_event)
    reader.start()

    try:
        # 等待用户按回车以结束本次录制
        input()
    except KeyboardInterrupt:
        # 用户按 Ctrl+C，终止录制并把中断抛给外层
        stop_event.set()
        try:
            proc.terminate()
        except Exception:
            pass
        reader.join(timeout=1)
        raise

    # 用户按回车，结束本次录制
    stop_event.set()
    # 尝试优雅结束子进程
    try:
        proc.terminate()
    except Exception:
        pass
    # 等待子进程结束一会
    try:
        proc.wait(timeout=1)
    except Exception:
        try:
            proc.kill()
        except Exception:
            pass

    reader.join(timeout=1)
    used_proto = reader.protocol or protocol
    return used_proto, reader.found


def write_keymap(path, mappings, default_protocol):
    with open(path, 'w', encoding='utf-8') as f:
        f.write('# keymap file generated by ir_key_recorder.py\n')
        f.write('# format: <name> <protocol> <comma-separated scancodes>\n')
        f.write('# example: POWER nec 0xa59b,0xa5dd\n')
        f.write('\n')
        for name, (proto, codes) in mappings.items():
            if not codes:
                continue
            proto_to_write = proto or default_protocol
            f.write(f"{name} {proto_to_write} {','.join(codes)}\n")


def main():
    parser = argparse.ArgumentParser(description='Record IR scancodes from ir-keytable and save a simple keymap file.')
    parser.add_argument('--protocol', '-p', default='nec', help='protocol to pass to ir-keytable (default: nec)')
    parser.add_argument('--device', '-s', default='rc1', help='device passed to -s (default: rc0)')
    parser.add_argument('--output', '-o', default='keymap.txt', help='output keymap filename (default: keymap.txt)')
    args = parser.parse_args()

    print('ir_key_recorder: enter key name and press Enter to start recording. Press Enter again to stop recording.')
    print('When prompted for key name, an empty name (just Enter) will save and exit.')
    print(f"Using protocol={args.protocol} device={args.device} output={args.output}")
    print('Note: the script will try to run with `stdbuf -oL ir-keytable ...` to get line-buffering.')
    print('If your system does not have stdbuf, the script will fall back but you may experience delayed lines.')
    print()

    mappings = OrderedDict()

    try:
        while True:
            raw_name = input('Key name (empty -> save & exit): ')
            name = raw_name.strip().replace(' ', '_')
            if name == '':
                break
            print(f"Recording for '{name}'. Press Enter to stop recording...")
            proto_used, codes = record_one_key(args.protocol, args.device)
            if not codes:
                print(f"No scancodes recorded for '{name}'. Skipping.")
            else:
                print(f"Recorded for '{name}': {', '.join(codes)}")
                mappings[name] = (proto_used, codes)
            print()
    except KeyboardInterrupt:
        print('\nInterrupted by user. Saving what we have...')

    if not mappings:
        print('No keys recorded. Exiting without writing file.')
        return

    try:
        write_keymap(args.output, mappings, args.protocol)
        print(f"Saved {len(mappings)} keys to {args.output}")
    except Exception as e:
        print(f"Failed to write output file: {e}")


if __name__ == '__main__':
    main()
